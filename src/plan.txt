class BlindMove extends Plan {
    /**
     * @param {Option} desire
     * @returns {boolean}
     */
    isApplicableTo(desire) {
        if (desire.args?.maxSteps) {
            if (desire?.path?.length > desire?.args?.maxSteps) {
                return false
            }
        }

        logger.info(`desire ${JSON.stringify(desire)} is applicable`)
        return true
    }

    async executeWithSignal({ x, y, args }, signal) {
        try {
            signal.throwIfAborted()
            // const maxAttempts = (1000 / speed) * 5
            const maxAttempts = 10
            var attempts = 0

            var path = []

            if (path[0]?.x == Math.round(me.x) && path[0]?.y == Math.round(me.y)) {
                path = args.path
            } else {
                path = finder.findPath(
                    { x: Math.round(me.x), y: Math.round(me.y) },
                    { x, y },
                    pathFindingGrid,
                ).path
            }

            signal.throwIfAborted()
            var i = 0
            while (i < path.length) {
                signal.throwIfAborted()
                const coord = path[i]
                var xMe = Math.round(me.x)
                var yMe = Math.round(me.y)

                /** @type {{x:number,y:number}|false} */
                var res = undefined

                if (xMe == coord.x - 1) {
                    res = await client.move("right")
                } else if (xMe == coord.x + 1) {
                    res = await client.move("left")
                } else if (yMe == coord.y - 1) {
                    res = await client.move("up")
                } else if (yMe == coord.y + 1) {
                    res = await client.move("down")
                }

                xMe = Math.round(me.x)
                yMe = Math.round(me.y)

                /*
                const isOverParcel = [...parcels.values()].some((p) => p.x == xMe && p.y == yMe)
                if (isOverParcel) {
                    await client.pickup()
                }

                const isOverDelivery = deliveries.some((d) => d.x == xMe && d.y == yMe)
                if (isOverDelivery) {
                    await client.putdown()
                }
                */

                if (res === false) {
                    if (attempts === maxAttempts) {
                        throw new Error(
                            `Impossible to reach the end of the path, it should be (${coord.x}, ${coord.y}) but it is (${xMe},${yMe})`,
                        )
                    }

                    attempts++
                    logger.info(`retry ${attempts} / ${maxAttempts}`)
                } else {
                    i++
                    attempts = 0
                }
            }
        } catch (error) {
            logger.error(`Error in go_to: ${error}`)
            this.stop()
            throw error
        }
    }

    #name = "go_to"
    get name() {
        return this.#name
    }
}